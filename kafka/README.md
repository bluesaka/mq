## Kafka延迟消息

- 1.生产者把消息发送到延迟队列
- 2.延迟服务把延迟队列里超过延迟时间的消息写入真实队列
- 3.消费者消费真实队列里的消息

## kafka常见问题

### 1. 顺序消费
`kafka`的`topic`是无序的，但`topic`中的每个`partition`内部消息是有序的，可以将消息根据业务进行分组，
例如同一个商户或同一个订单的消息(注意分配均匀，防止落地不均造成消息堆积等问题)写到同一个`partition`，
`topic`创建5个`partition`，部署5个消费者节点进行消费，保证消息顺序消费。

### 2. 重试机制
消息消费不成功的情况，如一个订单的下单和支付的消息，由于网络等问题，导致下单的消息没有消费成功，
后续支付的消息也会因找不到相关订单而消费失败。此时可以采用重试机制，如消费失败则重试3-5次直到成功，
还不行则保存到重试表中进行异步重试，后续相关的消息在消费前先判断重试表中是否有记录，有的话直接保存到
重试表中。

### 3. 消息积压
消息积压的情况比较多，常见的有

1. 消息体过大
`kafka`的消息从生产到消费会经过多次`io`，若消息体过大，会影响生成和消费的速度，浪费服务器的磁盘空间，
容易导致消息堆积。此时需优化消息结构，如订单消息只需要关键信息，不需要关心中间状态，在消息订单消息时，
不依赖消息里的订单信息，二是通过查询订单系统的状态来处理。

2. 消息路由不合理
在消息分配到`partition`时，需根据业务来做路由规则。如通过商户来路由，可能存在某些商户订单量很大，
导致某个`partition`的消息很多，导致消息堆积，通过调整消息路由规则来优化。

3. 消费者效率低
可以通过增加消费者的线程数来提高消费效率

### 4. 消息重复消费
`kafka`支持三种消息消费模式：
- `at most once` 最多一次
- `at least once` 至少一次
- `at exactly one` 精准投第一次
`kafka`默认模式是`at least once`，此时要保证幂等处理，通过分布式锁等技术处理。

## Kafka客户端

- 不采用 [Sarama](https://github.com/Shopify/sarama)
- 采用 [Confluent](https://github.com/confluentinc/confluent-kafka-go/kafka)

Sarama Go客户端存在以下已知问题：
- 当Topic新增分区时，Sarama Go客户端无法感知并消费新增分区，需要客户端重启后，才能消费到新增分区。
- 当Sarama Go客户端同时订阅两个以上的Topic时，有可能会导致部分分区无法正常消费消息。
- 当Sarama Go客户端的消费位点重置策略设置为`Oldest(earliest)`时，如果客户端宕机或服务端版本升级，由于Sarama Go客户端自行实现OutOfRange机制，有可能会导致客户端从最小位点开始重新消费所有消息。

参考:
- [为什么不推荐使用Sarama Go客户端收发消息？](https://help.aliyun.com/document_detail/266782.html)
- [关于 Kafka 应用开发知识点的整理](https://pandaychen.github.io/2022/01/01/A-KAFKA-USAGE-SUMUP-2/)

# Reference
- `https://www.jianshu.com/p/449074d97daf`
